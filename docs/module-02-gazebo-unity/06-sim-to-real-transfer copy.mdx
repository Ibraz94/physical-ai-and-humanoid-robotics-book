---
title: Chapter 6 - Sim-to-Real Transfer
sidebar_position: 6
slug: /module-02/sim-to-real-transfer
---

### **Understanding the Sim-to-Real Gap**

  

Why do simulated behaviors fail on real robots?

  

**Physics Discrepancies:**

- Simulated friction doesn't perfectly match reality

- Contact dynamics are approximated

- Flexible components (cables, soft parts) hard to model

- Mechanical backlash not captured

  

**Sensor Differences:**

- Simulated cameras have perfect optics

- Real cameras have distortion, noise, chromatic aberration

- Timing and synchronization differ

  

**Actuator Reality:**

- Real motors have response delays

- Torque limits vary with temperature

- Wear and tear affects performance

  

**Environmental Complexity:**

- Real environments have unexpected clutter

- Lighting varies unpredictably

- Surfaces aren't perfectly flat

  

### **Strategy 1: System Identification**

  

Measure real parameters and update simulation.

  

**Friction Calibration:**

  

```python

import rclpy

from rclpy.node import Node

from geometry_msgs.msg import Twist

from nav_msgs.msg import Odometry

import numpy as np

import time

  

class  FrictionCalibrator(Node):

def  __init__(self):

super().__init__('friction_calibrator')

self.cmd_pub = self.create_publisher(Twist, '/cmd_vel', 10)

self.odom_sub = self.create_subscription(Odometry, '/odom',

self.odom_callback, 10)

self.velocities = []

self.start_time = None

def  odom_callback(self, msg):

if  self.start_time is  not  None:

vel = msg.twist.twist.linear.x

elapsed = self.get_clock().now().nanoseconds / 1e9 - self.start_time

self.velocities.append((elapsed, vel))

def  run_calibration(self):

# Accelerate to constant velocity

cmd = Twist()

cmd.linear.x = 1.0

self.cmd_pub.publish(cmd)

time.sleep(3.0)

# Stop motors and coast

cmd.linear.x = 0.0

self.cmd_pub.publish(cmd)

self.start_time = self.get_clock().now().nanoseconds / 1e9

time.sleep(10.0)

# Analyze deceleration

self.calculate_friction()

def  calculate_friction(self):

times = np.array([v[0] for v in  self.velocities])

vels = np.array([v[1] for v in  self.velocities])

# Fit exponential decay: v(t) = v0 * exp(-friction * t)

from scipy.optimize import curve_fit

def  decay(t, v0, friction):

return v0 * np.exp(-friction * t)

params, _ = curve_fit(decay, times, vels, p0=[1.0, 0.1])

friction_coeff = params[1]

self.get_logger().info(f'Friction coefficient: {friction_coeff:.4f}')

return friction_coeff

```

  

Run on real robot, then update Gazebo friction to match.

  

### **Strategy 2: Domain Randomization**

  

Randomize simulation aggressively so reality is just one sample from the distribution.

  

**What to Randomize:**

- Friction (±50%)

- Mass (±20%)

- Lighting (±100%)

- Sensor noise (±50%)

- Actuator delays (0-50ms)

- Visual textures

- Object positions

  

**Gazebo Domain Randomization Plugin:**

  

```cpp

#include  <gazebo/gazebo.hh>

#include  <gazebo/physics/physics.hh>

#include  <random>

  

namespace  gazebo

{

class  DomainRandomization : public  WorldPlugin

{

private:

std::mt19937 rng{std::random_device{}()};

physics::WorldPtr world;

event::ConnectionPtr updateConnection;

int counter = 0;

public:

void  Load(physics::WorldPtr  _world, sdf::ElementPtr  _sdf)

{

this->world = _world;

this->updateConnection = event::Events::ConnectWorldUpdateBegin(

std::bind(&DomainRandomization::OnUpdate, this));

}

  

void  OnUpdate()

{

if (++counter % 1000 == 0)

{

RandomizePhysics();

}

}

  

private:

void  RandomizePhysics()

{

std::uniform_real_distribution<double> friction_dist(0.5, 1.5);

for (auto model : this->world->Models())

{

for (auto link : model->GetLinks())

{

auto collision = link->GetCollision(0);

if (collision)

{

double mu = friction_dist(rng);

collision->GetSurface()->FrictionPyramid()->SetMuPrimary(mu);

}

}

}

}

};

  

GZ_REGISTER_WORLD_PLUGIN(DomainRandomization)

}

```

  

Models trained with domain randomization are more robust to real-world variations.

  

### **Strategy 3: Progressive Transfer**

  

Don't jump directly from simulation to reality.

  

**Phase 1: Sim-to-Sim**

- Train in Gazebo

- Test in Unity/Isaac Sim

- If behavior fails, simulators are inconsistent

  

**Phase 2: Sim-to-Simple-Real**

- Test simple behaviors on hardware (drive forward, turn)

- Validate sensor readings match simulation

- Adjust simulation parameters

  

**Phase 3: Sim-to-Real with Safety**

- Controlled environment (padded room for humanoids)

- Safety tethers or emergency stops

- Start with slow speeds

  

**Phase 4: Full Deployment**

- Gradually increase complexity

- Monitor failures

- Iterate simulation based on real-world data

  

### **Strategy 4: Real-to-Sim Loop**

  

Use real-world data to improve simulation:

  

```python

import rosbag2_py

from rclpy.serialization import deserialize_message

from sensor_msgs.msg import LaserScan

import numpy as np

  

class  SimulationUpdater:

def  __init__(self, bag_file):

self.bag_file = bag_file

def  extract_sensor_noise(self):

"""Extract noise characteristics from real sensor data"""

reader = rosbag2_py.SequentialReader()

storage_options = rosbag2_py.StorageOptions(

uri=self.bag_file,

storage_id='sqlite3'

)

converter_options = rosbag2_py.ConverterOptions('', '')

reader.open(storage_options, converter_options)

ranges = []

while reader.has_next():

(topic, data, t) = reader.read_next()

if topic == '/scan':

msg = deserialize_message(data, LaserScan)

ranges.extend([r for r in msg.ranges if r > 0.1])

ranges_arr = np.array(ranges)

noise_std = np.std(ranges_arr)

print(f"LiDAR noise: {noise_std:.4f}m")

return noise_std

```

  

### **Measuring Transfer Success**

  

Define metrics to track:

  

**Success Rate:** % of tasks completed successfully

**Performance Gap:**  `(Real time - Sim time) / Sim time * 100%`

**Safety Violations:** Number of collisions or falls

**Behavior Similarity:** KL divergence between sim/real action distributions

  

**Target Metrics:**

- Success rate: 80%

- Performance gap: 20%

- Safety violations: 5%

  

If metrics don't meet targets, iterate on simulation and try again.